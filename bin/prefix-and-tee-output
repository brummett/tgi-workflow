#!/usr/bin/env perl

use strict;
use warnings;
use POSIX qw(strftime uname);
use IPC::Open3 qw(open3);
use IO::Handle;

unless (@ARGV > 2) {
    die "expected OUTFILE ERRFILE COMMAND [ARGS]";
}

my $outf = shift @ARGV;
my $errf = shift @ARGV;

unless (@ARGV) {
    die "expected OUTFILE ERRFILE COMMAND [ARGS]";
}

$0 = 'tail-log err';

sub prefixlines {
    my ($in, $out, $prefix, $chk, $fname) = @_;

    my $fh = IO::File->new(">$fname");
    unless ($fh) {
        die "failed to open file $fname!";
    }
    $fh->autoflush(1);

    select $out;
    $| = 1;

    while (my $line = <$in>) {
        my $t = strftime('%Y-%m-%d %H:%M:%S%z', localtime);
        $fh->print($t, ' ', $prefix, ': ', $line);
        print($t, ' ', $prefix, ': ', $line);
        if ($chk && substr($line,0,6) eq 'open3:') {
            return 127;
        }
    }

    return;
}


my $hostname = (uname)[1];
$hostname = substr($hostname,0,index($hostname,'.'));

pipe OUT_R, OUT_W;
pipe ERR_R, ERR_W;
OUT_R->autoflush(1);
OUT_W->autoflush(1);
ERR_R->autoflush(1);
ERR_W->autoflush(1);

my $pid = open3('<&STDIN', '>&OUT_W', '>&ERR_W', @ARGV);

close OUT_W;
close ERR_W;

my $child = fork;
if ($child) {
    close OUT_R;

    my $fail = prefixlines(\*ERR_R,\*STDERR,$hostname, 1, $errf);

    waitpid($pid, 0);
    my $exit = $? >> 8;
    waitpid($child, 0);

    exit ($fail || $exit);
} elsif (defined $child) {
    close ERR_R;
    $0 = 'annotate-log out';

    prefixlines(\*OUT_R,\*STDOUT,$hostname, 0, $outf);

    exit;
} else {
    die "can't fork: $!";
}

## never reached.
